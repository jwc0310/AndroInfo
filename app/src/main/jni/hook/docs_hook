解析so文件，其实主要目的就是获得ELF文件中以下三个表的信息：

    字符串表：包含以空字符结尾的字符序列，使用这些字符来描绘符号和节名；
    符号表：  保存了一个程序在定位和重定位时需要的定义和引用的信息；
    重定位表：保存了需要重定位的符号的信息；

读取ELF文件头（ELF文件头起始于 ELF 文件开始的第一字节），取出：

    节头表的文件偏移（shdr_base），获取节头表在文件中的位置；
    节头表的项数（shnum），获取节头表的项数；
    与节名称字符串表关联的项的节头表索引（shstr_base），并将其缓存起来（shstr）；


    读取节头表索引，取出： 节的大小（sh_size）、节的名称（sh_name）；
    遍历节名，分别将节名为.dynsym、.dynstr、.got、.rel.plt的节缓存起来（dynsym_shdr、dynstr_shdr、got_shdr、relplt_shdr）；
    通过上一步获取的节，分别获得对应的表，并将其缓存；

    获取指定符号在got表的偏移地址：



    最后，基地址加上函数符号在GOT表中的地址就是这个函数在内存中的实际地址。


    首先写一个open函数用于替换旧的open函数，之后将这个函数的地址替换到目标so的open函数地址。

    地址替换

    当运行目标so库中的open函数时，执行流程会跳转到我们上面自定义的hook_open函数。